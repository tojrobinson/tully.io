---
title: To Create or Not to Create? That is the Question
author: Tully Robinson
layout: post
---
As a programmer, one of the most common decision points in any project is whether to add functionality by way of an existing module of code or to write something from scratch. Sometimes the decision is easy, e.g., if you planned on incorporating database functionality to a web site, it's unlikely that implementing your own DBMS would be the best course of action.

For the other times, it can become a drawn out process. A decision in either direction can potentially lead you down a long and winding path that must later be retraced. Taking the module option, you are faced with a decision between potentially numerous available implementations as well as the task of merging an external code base with your own. Similarly, taking the self-implementation route, there are often many relevant design patterns to consider as well as various implementation difficulties. Since, as mortals, we are all afforded a finite amount of time, I feel that an intuition in this particular situation is an asset worth having.

Traditionally, I have had a strong inclination towards implementing everything myself, often at the expense of productivity. I can recall, when starting out in JavaScript and faced with the task of sorting a list of elements, I decided to write my own implementation of quicksort (Stallman knows why! Also, see [premature optimisation](http://c2.com/cgi/wiki?PrematureOptimization)). When this proved indistinguishable or slightly slower than JavaScript's `Array.prototype.sort`, I tried again by implementing mergesort with an insertion sort optimisation only to achieve a similar result. Hours later, I yielded to simply using the native sort method and moved on having achieved almost no forward momentum.

I can also remember a time when I felt that using frameworks allowed too much 'magic' to happen; that they were too much of an abstraction and I would never be able to debug my project. Perhaps it comes from a background in C or just the scientific mindset of needing to understand something completely, including the minutia (or maybe its just plain nubery); in any case, it has been the Achilles' heel to my productivity and the main reason for not finishing projects. As such, I have committed to writing this post as a way of reminding myself to try and direct my creative urges to where they are needed most.

I certainly don't intend to eliminate my superfluous implementation binges all together as they often lead to greater understanding and, occasionally, something great. Instead, I wish to improve my 'pragmatic average' by redirecting the majority of these inklings to areas where the greatest cost-benefit ratio is realised. An analogy would be: in poker, you try to get your chips into the pot when you have a high expected value (EV). That is, when you either stand to gain a lot by committing only a small amount of your chips, or when you are likely to win the pot. In the same way, by spending more of your time developing code that will likely be of great use or that doesn't require an exorbitant amount of time for minimal gain, over time, you should maximise the effect of your efforts. For everything else, the use of existing modules should be favoured.

When it comes to actually identifying the tasks that have the greatest EV, it appears there are two main determinants: time and your overall goal. How much working time do you have for the project? and what is the desired end state that the project is meant to achieve? The stricter the time constraint, the fewer the side projects (unnecessary implementations) you should allow yourself; the more important the end goal, the greater the EV of the side project should be. It becomes a qualitative process of evaluating these parameters and trying to create the path of greatest reward at all times.

Most likely, there is no definitive answer for when something should be implemented and when something should not as each project has its own peculiarities. In any case, I suspect that just being mindful of the main factors that go into such decisions, namely time, functional requirements and the desired end state, is enough to at least improve one's average productivity rate. So, next time you feel that JavaScript is just too much of an abstraction and writing your cat website in assembly seems like a reasonable option, try to re-evaluate the situation bearing within you the concepts outlined above.
